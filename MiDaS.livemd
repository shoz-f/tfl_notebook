# Untitled notebook

## Section

```elixir
defmodule Model do
  @model_file "midas_opt.tflite"

  @wearhouse "https://github.com/shoz-f/tinyML_livebook/releases/download/model/#{@model_file}"
  @local "/data/#{@model_file}"

  def file() do
    @local
  end

  def get() do
    Req.get!(@wearhouse).body
    |> then(fn x -> File.write(@local, x) end)
  end

  def rm() do
    File.rm(@local)
  end

  def exists?() do
    File.exists?(@local)
  end
end
```

```elixir
Model.get()
```

```elixir
defmodule Midas do
  # , model: Model.file()
  use TflInterp

  @midas_shape {256, 256}

  def apply(img) do
    # preprocess
    bin =
      img
      |> CImg.resize(@midas_shape)
      |> CImg.to_binary(range: {-2.0, 2.0})

    # prediction
    outputs =
      __MODULE__
      |> TflInterp.set_input_tensor(0, bin)
      |> TflInterp.invoke()
      |> TflInterp.get_output_tensor(0)
      |> Nx.from_binary({:f, 32})
      |> Nx.reshape({256, 256})

    # postprocess
    [min, max] =
      [Nx.window_min(outputs, {256, 256}), Nx.window_max(outputs, {256, 256})]
      |> Enum.map(&Nx.squeeze/1)
      |> Enum.map(&Nx.to_number/1)

    _result =
      outputs
      |> Nx.subtract(min)
      |> Nx.divide(max - min)
      |> Nx.to_binary()
      |> CImg.from_binary(256, 256, 1, 1, "<f4")
  end
end
```

```elixir
Midas.start_link(model: Model.file())
```

```elixir
TflInterp.info(Midas)
```

```elixir
Picam.Camera.start_link()
```

```elixir
img = Picam.next_frame()

Kino.render(Kino.Image.new(img, :jpeg))

CImg.from_binary(img)
|> Midas.apply()
|> CImg.resize({320, 240})
|> CImg.color_mapping(:jet)
|> CImg.to_binary(:png)
|> Kino.Image.new(:png)
```
